# ðŸ”µ Banco de Dados

DocumentaÃ§Ã£o de referÃªncia do subsistema de persistÃªncia do **Gerador de RelatÃ³rios**.  
Estrutura baseada em **SQLAlchemy (Declarative)** e **PostgreSQL**.

O banco de dados Ã© desenvolvido em PostgreSQL e hospedado na AWS Lightsail. As informaÃ§Ãµes sobre o banco estÃ£o a seguir:

| Campo | Valor |
| ----- | ----- |
| `DB_USER` | dbmasteruser |
| `DB_PASS` | *0G8^qqb`kOuW~b1TS#|Gcau]kblljf[ |
| `DB_HOST` | ls-6c91ee6007055f9ff152e646713483c83cbaa2d7.cez4ccce2p5m.us-east-1.rds.amazonaws.com |
| `DB_PORT` | 5432 |
| `DB_NAME`| dbgerador_relatorios |

Todo a estruturaÃ§Ã£o das tabelas, desde da criaÃ§Ã£o, implementaÃ§Ã£o atÃ© a usabilidade Ã© realizado via a biblioteca `SQLAlchemy`. A definiÃ§Ã£o de cada tabela Ã© feita em um arquivo exclusivo, sob o diretÃ³rio `src/backend/app/models/`.

## ðŸ”· Stack e DependÃªncias
Tecnologias Utilizadas 

- `PostgreSQL`: Tecnologia SQL usada para o banco de dados.
- `JSONB`: Tipo de coluna especÃ­fico ao PostgreSQL, cujo formato Ã© utilizado para guardar os relatÃ³rios gerados (nÃ£o Ã© uma extensÃ£o). 
- `SQLAlchemy`: Framework Python para utilizaÃ§Ã£o, criaÃ§Ã£o e conexeÃ§Ã£o com o banco de dados PostgreSQL


## ðŸ”· VisÃ£o Geral 
Temos 6 tabelas no banco de dados e lÃ³gica entre elas Ã© bem direta. 

Um **modelo de relatÃ³rio** Ã© composto por uma combinaÃ§Ã£o especÃ­fica de **capÃ­tulos** e diversos modelos podem reutilizar o mesmo capÃ­tulo (pense em introduÃ§Ã£o ou conclusÃ£o). Por esse motivo, para nÃ£o criar elementos repetidos no banco de dados temos a tabela `chapters`, que armazena os capÃ­tulos, e a tabela `reports` que armazena os modelos criados. Para conectÃ¡-los utiliza-se a tabela `relations` que estipula uma relaÃ§Ã£o muitos para muitos (many to many) entre qual capÃ­tulo estÃ¡ em qual modelo. 

Agora com relaÃ§Ã£o a criaÃ§Ã£o dos relatÃ³rios tambÃ©m temos 3 partes. Primeiro, relatÃ³rios criados sÃ£o armazenados na tabela `built_reports`. Nela, guardamos informaÃ§Ãµes do relatÃ³rio produzido, como tÃ­tulo, descriÃ§Ã£o, se estÃ¡ completo e data. AlÃ©m disso, o prÃ³prio relatÃ³rio Ã© armazenado nessa tabela, sob a coluna `report_obj` no formato `JSONB`. Ou seja, relatÃ³rios sÃ£o armazenados como JSON, na seguinte estrutura:
```JSON
{
  "title": "unnamed",
  "chapters": [
    {
      "text": "",
      "links": [],
      "title": "",
      "filled": true,
      "prompt": "",
      "position": "1",
      "description": ""
    },
    {
      "text": "",
      "links": [],
      "title": "",
      "filled": true,
      "prompt": "",
      "position": "2",
      "description": ""
    }
  ],
  "completed": false,
  "description": ""
}
```

AlÃ©m disso, armazenamos tambÃ©m os arquivos que foram utilizados para gerar essa relatÃ³rio. Para isso, inicialmente foi criado uma tabela que simula um `object_storage`, onde os arquivos sÃ£o armazenados como binÃ¡rios, em conjunto com outras informaÃ§Ãµes importantes sobre o arquivo. Ademais, para nÃ£o manter arquivos repetidos no banco de dados, tambÃ©m se estabelece uma conexÃ£o muitos para muitos (many-to-many) entre `built_reports` e `object_storage`. 


**â—OBS: Object Storage**
Inicialmente nÃ£o se havia acesso a um object storage real. Entretanto, com a transiÃ§Ã£o para a AWS, o serviÃ§o de object storage (`S3`) pode ser implementado sem custo adicional no Lightsail.

O cÃ³digo foi desenvolvido com essa possiblidade em mente. Dessa forma, a transiÃ§Ã£o para um object storage real deve ser direta.


```mermaid
erDiagram
  BUILT_REPORTS ||--o{ STORAGE_RELATION : has
  OBJECT_STORAGE ||--o{ STORAGE_RELATION : contains
  CHAPTERS ||--o{ RELATIONS : maps
  REPORTS  ||--o{ RELATIONS : maps

  BUILT_REPORTS {
    int id PK
    string title UK
    string description
    json  report_obj
    boolean completed
    timestamp datetime
  }

  OBJECT_STORAGE {
    uuid id PK
    string filename UK
    string content_type
    bigint size_bytes
    bytes  data
    timestamp created_at
    timestamp updated_at
  }

  STORAGE_RELATION {
    uuid   UUID PK  
    string report_title PK 
    string chapter_title PK
  }

  CHAPTERS {
    int id PK
    string title UK
    text   prompt
    string description
  }

  REPORTS {
    int id PK
    string title UK
    string description
  }

  RELATIONS {
    string chapter_title PK 
    string report_title  PK 
    string position
  }
``` 

- **Tabelas**
  - `chapters` â€” Armazena o tÃ­tulo, prompt e descriÃ§Ã£o dos capÃ­tulos criados
  - `reports` â€” Armazena o tÃ­tulo e descriÃ§Ã£o dos modelos criados
  - `relations` â€” RelaÃ§Ã£o muitos para muitos (many to many) entre os modelos e os capÃ­tulos, tambÃ©m contÃ©m a informaÃ§Ã£o da ordem em que aquele capÃ­tulo aparece no modelo
  - `built_reports` â€” Armazena os relatÃ³rios prontos, com as informaÃ§Ãµes substituÃ­das. RelatÃ³rios sÃ£o armazenados em colunas `JSONB` do PostgreSQL. 
  - `object_storage` â€” Simula um object storage para armazenar os arquivos enviados para elaboraÃ§Ã£o do relatÃ³rio.
  - `storage_relation` â€” ConexÃ£o muitos para muitos entre os relatÃ³rios construÃ­dos e os arquivos.


---


## ðŸ”¶ ReferÃªncia das Tabelas / Modelos

### ðŸ”¸`chapters` â€” `app.models.chapters.Chapter`

| Campo       | Tipo           | Chave | RestriÃ§Ãµes / Notas                  |
|-------------|----------------|-------|-------------------------------------|
| `id`        | Integer        | PK    | Autoincremento                      |
| `title`     | String(255)    | UK    | `nullable=False`                    |
| `prompt`    | Text           | â€”     | `nullable=False`                    |
| `description`| String(255)   | â€”     | Opcional                            |


**Relacionamentos**
- `relations: List[Relation]` â€” junÃ§Ã£o com `reports` (`back_populates="chapter"`, `cascade="all, delete-orphan"`).

**Invariantes**
- `title` Ãºnico.
- RemoÃ§Ã£o de um capÃ­tulo remove suas relaÃ§Ãµes.

**Exemplo**
``` python
# recuperar capÃ­tulos com suas posiÃ§Ãµes em um report
q = (
    session.query(Relation)
    .filter(Relation.report_title == "RelatÃ³rio TÃ©cnico")
    .order_by(Relation.position.asc())
    .all()
)
```

---

### ðŸ”¸ `reports` â€” `app.models.reports.Report`

| Campo         | Tipo        | Chave | RestriÃ§Ãµes / Notas |
| ------------- | ----------- | ----- | ------------------ |
| `id`          | Integer     | PK    | Autoincremento     |
| `title`       | String(255) | UK    | `nullable=False`   |
| `description` | String(255) | â€”     | Opcional           |

**Relacionamentos**
- `relations: List[Relation]` â€” junÃ§Ã£o com `chapters` (`back_populates="report"`, `cascade="all, delete-orphan"`).

**Invariantes**
- `title` Ãºnico.

---

### ðŸ”¸`relations` â€” `app.models.relations.Relation`

| Campo           | Tipo        | Chave | RestriÃ§Ãµes / Notas                                 |
|-----------------|-------------|-------|----------------------------------------------------|
| `chapter_title` | String(255) | PK    | FK â†’ `chapters.title`                              |
| `report_title`  | String(255) | PK    | FK â†’ `reports.title`                               |
| `position`      | String      | â€”     | `nullable=False` (avaliar migraÃ§Ã£o para `Integer`) 

**Relacionamentos**
- `chapter: Chapter` (`back_populates="relations"`).
- `report: Report` (`back_populates="relations"`).

**Notas**
- `position` Ã© `String`; caso a ordenaÃ§Ã£o seja numÃ©rica, considerar migraÃ§Ã£o para `Integer`.
- Como as FKs sÃ£o por `title`, renomeaÃ§Ãµes de tÃ­tulos exigem atualizaÃ§Ã£o transacional das junÃ§Ãµes.

---

### ðŸ”¸ `built_reports` â€” `app.models.built_reports.BuiltReports`

| Campo       | Tipo                     | Chave | RestriÃ§Ãµes / Notas                                             |
|-------------|---------------------------|-------|-----------------------------------------------------------------|
| `id`        | Integer                  | PK    | Autoincremento                                                  |
| `title`     | String                   | UK    | â€”                                                               |
| `description`| String                  | â€”     | Opcional                                                        |
| `report_obj`| JSONB (MutableDict)      | â€”     | `default=dict`; alteraÃ§Ãµes *in-place* sÃ£o rastreadas            |
| `completed` | Boolean                  | â€”     | Opcional                                                        |
| `datetime`  | DateTime(timezone=True)  | â€”     | `server_default=func.now()`, `nullable=False`                   |

**Ãndices**
- `ix_built_reports_report_obj` (`report_obj`) com `postgresql_using="gin"`.

**Relacionamentos**
- `storage_relation: List[StorageRelation]` â€” anexos por capÃ­tulo (`back_populates="built_report"`, `cascade="all, delete-orphan"`).

**Notas**
- `MutableDict` habilita rastreamento de alteraÃ§Ãµes *in-place* no JSON.

**Exemplos**
```sql
-- consulta por conteÃºdo JSONB (aproveita o Ã­ndice GIN)
SELECT
ch ->> 'title' AS title_field,
ch ->> 'text' AS text_field
FROM
built_reports AS r
CROSS JOIN LATERAL
jsonb_array_elements(r.report_obj->'chapters') AS ch
```

### ðŸ”¸ `object_storage` â€” `app.models.object_storage.ObjectStorage`

**Papel**: armazenamento de blobs com metadados.

**Campos**

| Campo        | Tipo                     | Chave | RestriÃ§Ãµes / Notas                                  |
|--------------|--------------------------|-------|-----------------------------------------------------|
| `id`         | UUID (as_uuid=True)      | PK    | `default=uuid.uuid4`                                |
| `filename`   | String                   | UK    | â€”                                                   |
| `content_type`| String                  | â€”     | MIME type                                           |
| `size_bytes` | BigInteger               | â€”     | Tamanho em bytes                                    |
| `data`       | LargeBinary              | â€”     | ConteÃºdo binÃ¡rio                                    |
| `created_at` | DateTime(timezone=True)  | â€”     | `server_default=func.now()`, `nullable=False`       |
| `updated_at` | DateTime(timezone=True)  | â€”     | `server_default=func.now()`, `onupdate=func.now()`  |

**Relacionamentos**
- `storage_relation: List[StorageRelation]` (`back_populates="object_storage"`, `cascade="all, delete-orphan"`).

**Exemplo**
```python
obj = ObjectStorage(
    filename="intro.odt",
    content_type="application/vnd.oasis.opendocument.text",
    size_bytes=len(data_bytes),
    data=data_bytes,
)
session.add(obj); session.commit()
```

---

### ðŸ”¸ `storage_relation` â€” `app.models.storage_relation.StorageRelation`

| Campo           | Tipo        | Chave | RestriÃ§Ãµes / Notas                               |
| --------------- | ----------- | ----- | ------------------------------------------------ |
| `UUID`          | UUID        | PK    | FK â†’ `object_storage.id`; `index=True`           |
| `report_title`  | String(255) | PK    | FK â†’ `built_reports.title`                       |
| `chapter_title` | String(255) | PK    | **Sem FK explÃ­cita** (recomenda-se adicionar FK) |

**Relacionamentos**
- `built_report: BuiltReports` (`back_populates="storage_relation"`).
- `object_storage: ObjectStorage` (`back_populates="storage_relation"`).

**Exemplo**
```python
link = StorageRelation(
    UUID=obj.id,
    report_title=br.title,
    chapter_title="IntroduÃ§Ã£o",
)
session.add(link); session.commit()
```