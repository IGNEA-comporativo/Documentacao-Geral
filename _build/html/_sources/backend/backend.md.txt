<!-- # üîµ Backend
Para essa aplica√ß√£o, o backend √© respons√°vel por estabelecer o servidor de backend para as requisi√ß√µes e servir os arquivos est√°ticos do frontend.


## üî∑ üî∑ Stack e depend√™ncias

Tecnologias Utilizadas 

- `Python`: Linguagem de programa√ß√£o utilizada no backend
- `FastAPI`: Framework Python para desenvolvimento de servidores backend
- `SQLAlchemy`: Framework Python para utiliza√ß√£o e conexe√ß√£o com o banco de dados PostgreSQL
- `uv`: Gerenciador de ambientes Python (substituto moderno do `venv`)

--- 

## üî∑ üî∑ Estrutura  

 ^#\s 
-->


# üîµ Backend

**Conven√ß√µes gerais**
- Formatos de dados: JSON, exceto upload de arquivos (multipart/form-data) e download bin√°rio.
- Autentica√ß√£o: baseada em sess√£o (cookies) para rotas protegidas de auth.
- C√≥digos de status: 2xx sucesso; 4xx erro do cliente; 5xx erro do servidor.

---

## üî∑ Stack e depend√™ncias

Tecnologias utilizadas no backend e servi√ßos auxiliares. Esta lista reflete o que est√° implementado nos m√≥dulos do projeto.



- `Python`: Linguagem principal do backend.

- `FastAPI`: Framework para defini√ß√£o das rotas e inje√ß√£o de depend√™ncias.

- `Starlette`: Base utilizada pelo FastAPI (sess√µes via `SessionMiddleware`, `Request`, `Response`, `FileResponse`, `Config` para `.env`).

- `Pydantic`: Modelagem e valida√ß√£o de dados (schemas de entrada/sa√≠da).

- `SQLAlchemy ORM`: Acesso ao banco e mapeamento das entidades (`Session`, consultas, `text` SQL quando necess√°rio).

- `PostgreSQL`: Banco de dados relacional (uso de tipos JSON/JSONB em consultas e agrega√ß√µes).

- `Google GenAI (Gemini)`: SDK `google.genai` e camada `app.services.AI` para gera√ß√£o de conte√∫do de cap√≠tulos a partir de prompts e anexos.

- `Manipula√ß√£o de documentos`: Fun√ß√£o `createDocument` (`app.services.documentManip.replaceDocument`) para compor o `.odt` e servi√ßo externo do LibreOffice (processamento/headless) acionado via HTTP.

- `Requests`: Cliente HTTP para integra√ß√£o com o servi√ßo do LibreOffice.

- `uv`: Gerenciador de ambientes/execu√ß√£o para projetos Python, alternativa moderna ao `venv`.

Observa√ß√µes de configura√ß√£o:
- Vari√°veis de ambiente via `.env` com `starlette.config.Config` (ex.: `DEV_PASSWORD` para autentica√ß√£o).  
- Caminhos e endpoints de servi√ßos externos (ex.: diret√≥rios de template e documento tempor√°rio, endpoint do servi√ßo LibreOffice) devem ser definidos na configura√ß√£o da aplica√ß√£o.


## üî∑ Vis√£o geral

O backend do Gerador de Relat√≥rios organiza todo o ciclo de vida de cria√ß√£o de relat√≥rios corporativos. Ele oferece:

- **Gest√£o de modelos e cap√≠tulos:** Rotas para criar/atualizar/excluir modelos de relat√≥rio e cap√≠tulos reutiliz√°veis.

- **Ordena√ß√£o e composi√ß√£o:** Defini√ß√£o da ordem dos cap√≠tulos por modelo e montagem de objetos de relat√≥rio prontos para edi√ß√£o.

- **√Årea de trabalho persistida:** Cria√ß√£o e atualiza√ß√£o de relat√≥rios ‚Äúconstru√≠dos‚Äù (`built_reports`) com estado completo de edi√ß√£o.  

- **Anexos por cap√≠tulo:** Upload de arquivos, armazenamento e associa√ß√£o consistente ao par `(report_title, chapter_title)`.

- **Gera√ß√£o de conte√∫do assistida por IA**: Produ√ß√£o de texto por cap√≠tulo com base no `prompt` e anexos, utilizando Gemini.

- **Exporta√ß√£o para `.odt`**: Composi√ß√£o do documento a partir de template, seguida de p√≥s-processamento pelo LibreOffice headless e download do arquivo final.  
  
- **Autentica√ß√£o simples por sess√£o**: Prote√ß√£o de rotas com senha de desenvolvimento e sess√£o baseada em cookies.  

## üî∑ Estrutura
Para mais informa√ß√µes sobre a gera√ß√£o de relat√≥rios, `.odt` e a utiliza√ß√£o do libreoffice, veja a se√ß√£o [Gera√ß√£o de Documentos](geracao_documentos.md).

### üîπRoteadores (FastAPI)  
  - `auth.py`: login/logout e endpoint protegido por sess√£o.  
  - `reports.py`: CRUD de modelos de relat√≥rio.  
  - `chapters.py`: CRUD de cap√≠tulos.  
  - `relations.py`: CRUD da ordem de cap√≠tulos por modelo.  
  - `desktop.py`: montagem/leitura/salvamento de relat√≥rios constru√≠dos e agrega√ß√£o de metadados de arquivos.  
  - `storage.py`: upload e download de arquivos e v√≠nculo com cap√≠tulos/relat√≥rios.  
  - `report_generation.py`: gera√ß√£o de conte√∫do com IA e exporta√ß√£o `.odt`.

### üîπServi√ßos  
  - `app.services.AI`: encapsula chamadas ao Gemini.  
  - `app.services.documentManip.replaceDocument.createDocument`: comp√µe o documento a partir do template.  
  - Servi√ßo externo LibreOffice: endpoint HTTP para p√≥s-processamento do `.odt`.

### üîπPersist√™ncia (SQLAlchemy + PostgreSQL)  
  - Entidades principais: `reports`, `chapters`, `relations`, `built_reports`, `object_storage`, `storage_relation`.  
  - `built_reports.report_obj` mant√©m o estado edit√°vel do relat√≥rio (cap√≠tulos, textos, flags, etc.).  
  - Consultas h√≠bridas: ORM para CRUD e SQL textual para trechos espec√≠ficos (JSON/JSONB).

### üîπFluxo operacional t√≠pico  
  1) Criar modelos e cap√≠tulos.  
  2) Definir a ordem dos cap√≠tulos por modelo.  
  3) Montar a √°rea de trabalho do relat√≥rio (a partir do modelo ou de uma vers√£o j√° constru√≠da).  
  4) Anexar arquivos por cap√≠tulo conforme necess√°rio.  
  5) Gerar texto com IA por cap√≠tulo.  
  6) Salvar/atualizar a vers√£o constru√≠da do relat√≥rio.  
  7) Exportar o `.odt` final.

```{mermaid}
flowchart LR
    FE[Frontend] -->|REST/JSON| API[FastAPI App]

    subgraph Routers
      AUTH[auth.py Sess√£o/credenciais]
      REPS[reports.py Modelos de relat√≥rio]
      CHAP[chapters.py Cap√≠tulos]
      REL[relations.py Ordem de cap√≠tulos]
      DESK[desktop.py √Årea de trabalho]
      STOR[storage.py Upload/Download]
      GEN[report_generation.py IA/Exporta√ß√£o]
    end

    API --> AUTH
    API --> REPS
    API --> CHAP
    API --> REL
    API --> DESK
    API --> STOR
    API --> GEN


    subgraph Servi√ßos Externos
      DOC[createDocument com template]
      LO[LibreOffice headless pipeline HTTP]
      AI[Google GenAI Gemini]
    end

    GEN --> DOC
    DOC --> LO
    GEN --> AI
```

## üî∑ Autentica√ß√£o

### üîπPOST `/login`

Autentica o usu√°rio via senha de desenvolvimento (`DEV_PASSWORD` no `.env`) usando compara√ß√£o em tempo constante. Em caso de sucesso, grava `logged_in=True` e um `nonce` na sess√£o. 

<blockquote>

**Par√¢metros**

- Corpo (JSON):
  - `password`: string.

**Respostas**

- 200: `{ "success": true }`.
- 401: credenciais inv√°lidas.

</blockquote>


---

### üîπPOST `/logout`

Limpa a sess√£o, invalidando a autentica√ß√£o atual. Requer estar autenticado. 

<blockquote>

**Par√¢metros**

- Sem corpo. Requer cookie de sess√£o v√°lido.

**Respostas**

- 200: `{ "success": true }`.
- 401: se n√£o autenticado (via depend√™ncia). 
</blockquote>

---

### üîπGET `/protected`

Endpoint de exemplo que s√≥ responde quando autenticado; √∫til para health-check de sess√£o. 

<blockquote>

**Respostas**

- 200: `{ "message": "You made it inside!" }`.
- 401: se n√£o autenticado.



</blockquote>

---

## üî∑ Modelos de Relat√≥rio (`/ModelosRelatorios`)

CRUD sobre o modelo de relat√≥rio (metadados e descri√ß√£o).

### üîπPOST `/ModelosRelatorios/`

Cria um modelo de relat√≥rio, garantindo unicidade por t√≠tulo. 

<blockquote>

**Par√¢metros**

- Corpo (JSON) `schemas.ReportCreate`:
  - Campos esperados: `title` (string), `description` (string).  
    Observa√ß√£o: tipos e obrigatoriedade seguem o schema do projeto.

**Respostas**
- 200: objeto `schemas.Report` criado.
- 409: t√≠tulo j√° existente.


</blockquote>



### üîπPUT `/ModelosRelatorios/{id:int}`

Atualiza parcialmente um modelo existente via `model_dump(exclude_unset=True)`. 

<blockquote>

**Par√¢metros**

- Path:
  - `id`: inteiro.
- Corpo (JSON) `schemas.ReportCreate`:
  - Campos a atualizar (n√£o enviados n√£o s√£o alterados).

**Respostas**

- 200: objeto `schemas.Report` atualizado.
- 404: id inexistente.

</blockquote>



### üîπGET `/ModelosRelatorios/{title}`

Lista todos os modelos com o t√≠tulo informado (pode retornar m√∫ltiplos, dependendo do banco). 

<blockquote>

**Par√¢metros**

- Path:
  - `title`: string.

**Respostas**

- 200: lista de `schemas.Report`.
- 404: nenhum encontrado.

</blockquote>



### üîπGET `/ModelosRelatorios/`

Retorna todos os modelos cadastrados. 

<blockquote>

**Respostas**

- 200: lista de `schemas.Report`.

</blockquote>


### üîπDELETE `/ModelosRelatorios/{id:int}`

Remove um modelo por id. 
<blockquote>

**Par√¢metros**

- Path:
  - `id`: inteiro.

**Respostas**

- 200: `{ "message": "Report deleted", "id": <id> }`
- 404: n√£o encontrado.
</blockquote>


---

## üî∑ Cap√≠tulos (`/CriadorCapitulos`)

Ger√™ncia os cap√≠tulos reutiliz√°veis dos relat√≥rios.

### üîπPOST `/CriadorCapitulos/`

Cria cap√≠tulo; t√≠tulo √© obrigat√≥rio e √∫nico. 

<blockquote>

**Par√¢metros**

- Corpo (JSON) `schemas.ChapterCreate`:
  - Campos esperados: `title` (string), `prompt` (string), `description` (string).

**Respostas**

- 200: objeto `schemas.Chapter`.
- 404: t√≠tulo ausente.
- 409: t√≠tulo j√° existe.
</blockquote>


### üîπPUT `/CriadorCapitulos/{id:int}`

Atualiza cap√≠tulo existente. 

<blockquote>

**Par√¢metros**

- Path:
  - `id`: inteiro.
- Corpo (JSON) `schemas.ChapterCreate`:
  - Campos a atualizar.

**Respostas**

- 200: `schemas.Chapter` atualizado.
- 404: id n√£o encontrado.

</blockquote>


### üîπGET `/CriadorCapitulos/{title}`

Retorna cap√≠tulos pelo t√≠tulo. 

<blockquote>

**Par√¢metros**

- Path:
  - `title`: string.

**Respostas**

- 200: lista de `schemas.Chapter`.
- 404: n√£o encontrado.
</blockquote>


### üîπGET `/CriadorCapitulos/`

Retorna todos os cap√≠tulos. 

<blockquote>

**Respostas**

- 200: lista de `schemas.Chapter`.
- 404: nenhum cap√≠tulo cadastrado.
</blockquote>


### üîπDELETE `/CriadorCapitulos/{id:int}`

Apaga um cap√≠tulo por id. A fun√ß√£o n√£o retorna corpo expl√≠cito. 

<blockquote>

**Par√¢metros**

- Path:
  - `id`: inteiro.

**Respostas**

- 200: sem corpo (vazio).
- 404: n√£o encontrado.
</blockquote>

---

## üî∑ Rela√ß√µes entre Modelo e Cap√≠tulos (`/ModelosRelatorios/relation`)

Define a ordem dos cap√≠tulos para um modelo de relat√≥rio.

### üîπGET `/ModelosRelatorios/relation/{report_title}`

Retorna a lista de cap√≠tulos com suas posi√ß√µes para o modelo informado. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.

**Respostas**

- 200: `List[schemas.ChapterWithOrder]`.

</blockquote>


### üîπPOST `/ModelosRelatorios/relation/`

Cria rela√ß√µes cap√≠tulo‚Üîmodelo a partir de `schemas.RelationCreate`. Gera erro se o `report_title` j√° possui rela√ß√µes. 

<blockquote>

**Par√¢metros**

- Corpo (JSON) `schemas.RelationCreate`:
  - `report_title`: string.
  - `chapters`: lista de objetos com `title` e `position`.

**Respostas**

- 200: sem corpo.
- 400: `report_title` ausente. 
- 409: rela√ß√µes j√° existentes para o `report_title`. 

</blockquote>


### üîπPUT `/ModelosRelatorios/relation/{report_id:int}`

Substitui as rela√ß√µes de um modelo: apaga as atuais e cria as novas. O `report_title` √© derivado do `report_id`. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_id`: inteiro.
- Corpo (JSON) `schemas.RelationCreate`:
  - Mesmo formato do POST.

**Respostas**

- 200: sem corpo.

</blockquote>


### üîπDELETE `/ModelosRelatorios/relation/{report_title}`

Apaga todas as rela√ß√µes de um modelo espec√≠fico. Retorna `1` em caso de sucesso. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.

**Respostas**

- 200: `1`.
- 404: t√≠tulo n√£o encontrado.

</blockquote>


## üî∑ √Årea de Trabalho (`/AreaDeTrabalho`)

Orquestra e exp√µe objetos compostos usados no front-end para montar relat√≥rios, com metadados e arquivos associados.

### üîπGET `/AreaDeTrabalho/lastReport`

Recupera o √∫ltimo relat√≥rio ‚Äúinacabado‚Äù cujo t√≠tulo come√ßa por `unnamedN` (maior `N`). Monta o objeto com cap√≠tulos e metadados de arquivos. 

<blockquote>

**Respostas**

- 200: `schemas.ReportWithFiles` com:
  - `id`, `title`, `description`, `completed`, `chapters`, `files`.
- 404: nenhum relat√≥rio inacabado.
- 200 com `{ "report": null }` em casos espec√≠ficos de erro interno tratado. 
</blockquote>

**Fluxo**

```{mermaid}
sequenceDiagram
  participant FE as Front-end
  participant API as GET /AreaDeTrabalho/lastReport
  participant DB as DB
  participant S as Object Storage

  FE->>API: Request
  API->>DB: Buscar √∫ltimo built_report com title like "unnamed%"
  DB-->>API: T√≠tulo
  API->>DB: get_report_model(title)
  API->>DB: Agregar arquivos por cap√≠tulo
  DB-->>API: Relat√≥rio Salvo
  S-->>API: Lista de arquivos (id, nome, tipo, tamanho)
  API-->>FE: ReportWithFiles (chapters + files)
```

---

### üîπGET `/AreaDeTrabalho/{report_title}`

Monta e retorna o objeto de relat√≥rio para um `report_title`. Se existir em `built_reports`, retorna a vers√£o constru√≠da; sen√£o, monta a partir do modelo de relat√≥rio e das rela√ß√µes. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.

**Respostas**

- 200: objeto com `id`, `title`, `description`, `chapters` e campos auxiliares nos cap√≠tulos (`docs`, `links`, `images`, `filled`, `text`, `position`). 

</blockquote>


### üîπGET `/AreaDeTrabalho/`

Retorna a lista de objetos de relat√≥rio para todos os t√≠tulos distintos encontrados em `reports.Report`. 

<blockquote>

**Respostas**

- 200: lista de objetos de relat√≥rio.

</blockquote>


### üîπPOST `/AreaDeTrabalho/`

Converte um `schemas.ReportObject` vindo do front-end em uma entrada em `built_reports`. Se `title` estiver vazio, gera automaticamente `unnamed{N}`. Se `title` existir, retorna conflito. Retorna `{ "title": <final> }`. 

<blockquote>

**Par√¢metros**

- Corpo (JSON) `schemas.ReportObject`:
  - `title`, `description`, `completed`, `chapters` etc.

**Regras**

- T√≠tulo vazio: auto-incremento `unnamedN` com base nos existentes. 
- T√≠tulo j√° existente: 409. 

**Respostas**

- 200: `{ "title": "unnamedN" | "<title>" }`.

</blockquote>


### üîπPUT `/AreaDeTrabalho/{report_title}`

Atualiza um relat√≥rio constru√≠do: remove a vers√£o anterior e adiciona a nova. Exige que o relat√≥rio exista. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.
- Corpo (JSON) `schemas.ReportObject`.

**Respostas**

- 200: objeto `built_reports.BuiltReports` persistido.
- 404: `report_title` n√£o existe. 

</blockquote>


**Fluxo de atualiza√ß√£o**

```{mermaid}
sequenceDiagram
  participant FE as Front-end
  participant API as PUT /AreaDeTrabalho/{title}
  participant DB as DB

  FE->>API: ReportObject atualizado
  API->>DB: Verifica exist√™ncia por title

  alt existe
    API->>DB: Deleta BuiltReports atual
    API->>DB: Insere nova vers√£o (add_report_model)
    DB-->>API: Novo registro
    API-->>FE: 200 com objeto
  else n√£o existe
    API-->>FE: 404
  end
```

---

## üî∑ Armazenamento de Objetos (`/objects`)

Upload e associa√ß√£o de arquivos aos cap√≠tulos de um relat√≥rio. Os bytes s√£o guardados em `ObjectStorage` e a associa√ß√£o cap√≠tulo‚Üîrelat√≥rio‚Üîarquivo em `StorageRelation`.

### üîπPOST `/objects/`

Recebe m√∫ltiplos arquivos e associa cada um ao par `(report_title, chapter_title)`. Se o nome do arquivo j√° existir, atualiza o registro (tipo de conte√∫do, bytes e tamanho). Caso a rela√ß√£o j√° exista para o arquivo, ignora; caso contr√°rio, cria. 

<blockquote>

**Par√¢metros**

- Form Data (multipart):
  - `chapter_title`: string.
  - `report_title`: string.
  - `files`: lista de arquivos.

**Respostas**

- 200: sem corpo (opera√ß√µes realizadas com sucesso).


</blockquote>

**Fluxo**

```{mermaid}

sequenceDiagram
  participant FE as Front-end
  participant API as POST /objects/
  participant DB as DB

  FE->>API: multipart (report_title, chapter_title, files[])
  loop para cada arquivo
    API->>DB: upsert em ObjectStorage (filename √∫nico)
    API->>DB: verificar StorageRelation(UUID, report_title, chapter_title)
    alt rela√ß√£o inexistente
      API->>DB: inserir StorageRelation
    else j√° existe
      API-->>DB: ignora
    end
  end
  API-->>FE: 200


  
```

---

### üîπGET `/objects/{report_title}`

Retorna a lista de blobs (bytes) de arquivos associados ao relat√≥rio. Observa√ß√£o: o filtro usa o campo `title` em `StorageRelation`, o que aparentemente deveria ser `report_title`. Verifique no modelo. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.

**Respostas**

- 200: lista de blobs bin√°rios (n√£o recomendado para consumo direto via JSON).


</blockquote>

---

### üîπGET `/objects/file/{file_id}`

Download de um arquivo por UUID, com cabe√ßalho `Content-Disposition` para for√ßar nome original. 

<blockquote>

**Par√¢metros**

- Path:
  - `file_id`: UUID.

**Respostas**

- 200: conte√∫do bin√°rio com `media_type` do arquivo e `filename` original.
- 404: arquivo n√£o encontrado.

</blockquote>



---

## üî∑ Gera√ß√£o de Relat√≥rios e Conte√∫do com IA (`/report`)

### üîπGET `/report/createReport/{report_title}`

Gera um documento `.odt` a partir de um relat√≥rio ‚Äúconstru√≠do‚Äù (`built_reports`).  
Fluxo: valida exist√™ncia do t√≠tulo, extrai `title` e `text` dos cap√≠tulos via SQL sobre `report_obj`, chama `createDocument` com `TEMPLATE_PATH` e `TEMP_DOC_PATH`, aciona um servi√ßo de LibreOffice para atualiza√ß√µes de numera√ß√£o e sum√°rio, e retorna o arquivo via streaming com nome `<report_title>.odt`. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string (deve existir em `built_reports`).

**Respostas**

- 200: arquivo `.odt` como `application/vnd.oasis.opendocument.text`.
- 404: t√≠tulo n√£o existe em `built_reports`.

</blockquote>


**Fluxo**

```{mermaid}
flowchart TD
  A[GET /report/createReport/title] --> B{title existe em built_reports?}
  B -- n√£o --> E[404]
  B -- sim --> C[Consulta cap√≠tulos: title/text]
  C --> D[createDocument TEMPLATE_PATH, TEMP_DOC_PATH]
  D --> F[Chama LO-RUNNER /libreoffice/process-file]
  F --> G[FileResponse _temp_report.odt como title.odt]
```

---

### üîπGET `/report/AI/{report_title}/{chapter_title}`

Gera texto para um cap√≠tulo usando IA (Gemini) com base no `prompt` do cap√≠tulo e arquivos anexados ao par `(report_title, chapter_title)`.  
Fluxo: busca arquivos do cap√≠tulo, extrai o `prompt` do JSON `report_obj` via SQL e chama `AI.call_gemini(prompt, [""], files_query)`. Retorna `{ "generated_text": <texto> }`. 

<blockquote>

**Par√¢metros**

- Path:
  - `report_title`: string.
  - `chapter_title`: string.

**Respostas**

- 200: `{ "generated_text": "<texto gerado>" }`.

</blockquote>


**Fluxo**

```{mermaid}
sequenceDiagram
  participant FE as Front-end
  participant API as GET /report/AI/{report}/{chapter}
  participant DB as DB
  participant IA as AI.call_gemini

  FE->>API: Request
  API->>DB: Buscar arquivos vinculados (data, filename, content_type)
  API->>DB: Buscar prompt do cap√≠tulo em built_reports.report_obj
  DB-->>API: files_query + prompt
  API->>IA: prompt + arquivos
  IA-->>API: generated_text
  API-->>FE: { generated_text }
```

---

## üî∑ Observa√ß√µes sobre schemas usados

Abaixo est√£o os contratos Pydantic que estruturam entradas e sa√≠das dos endpoints. Os nomes refletem o dom√≠nio do projeto e s√£o usados de forma consistente nas rotas descritas.

**Mapeamento r√°pido para as rotas**

- Modelos de Relat√≥rio: `ReportCreate` e `Report` em cria√ß√£o, atualiza√ß√£o, listagem e dele√ß√£o.
- Cap√≠tulos: `ChapterCreate`, `Chapter` e, quando necess√°rio, `ChapterWithOrder` na composi√ß√£o de relat√≥rios.
- Rela√ß√µes: `RelationCreate` e `ChapterHOrder` para criar/substituir a ordem de cap√≠tulos por relat√≥rio.
- √Årea de Trabalho: `ReportObject` para criar/atualizar relat√≥rios constru√≠dos, `ReportObjectOut` e `ReportWithFiles` para leituras que incluem cap√≠tulos e anexos, al√©m de `FileMeta` nos pontos de listagem/download de arquivos.

### Vis√£o estrutural

```{mermaid}
classDiagram
    namespace Reports{
    class ReportCreate {
      title: str
      description: Optional[str]
    }

    class Report {
      id: int
      title: str
      description: Optional[str]
    }

    class ReportObject {
      id: Optional[int]
      chapters: List~ChapterObject~
      completed: bool
    }

    class ReportObjectOut {
      chapters: List~ChapterObjectOut~
    }

    class FileMeta {
      uuid: UUID
      filename: str
      content_type: str
      size_bytes: int
      download_url: str
    }

    class ReportWithFiles {
      title: str
      description: Optional[str]
      completed: bool
      chapters: List~ChapterObjectOut~
      files: Dict~str, List~FileMeta~~
    }

    }

    namespace Chapters{
        class ChapterCreate {
      title: str
      prompt: str
      description: Optional[str]
    }

    class Chapter {
      id: int
      title: str
      prompt: str
      description: Optional[str]
    }

    class ChapterWithOrder {
      position: str
    }

    class ChapterHOrder {
      title: str
      prompt: str
      description: Optional[str]
      position: str
    }

    class ChapterObject {
      id: Optional[int]
      links: List~str~
      filled: bool
      text: str
      position: str
    }

    class ChapterObjectOut {
      docs: List
      images: List
    }
    }

    

    class RelationCreate {
      chapters: List~ChapterHOrder~
      report_title: str
    }

    class Relation {
      chapters_title: List
      report_title: str
      position: str
    }

    

    

    

    ReportCreate <|-- Report
    ChapterCreate <|-- Chapter
    Chapter <|-- ChapterWithOrder
    Chapter <|-- ChapterObject
    ChapterObject <|-- ChapterObjectOut
    Report <|-- ReportObject
    Report <|-- ReportObjectOut
    RelationCreate --> ChapterHOrder
    ReportWithFiles o-- FileMeta
    ReportWithFiles o-- ChapterObjectOut
```


---

